This file contains the combined code from multiple files in a folder.
The purpose is to provide the LLM with a single, consolidated file for analysis and understanding of the entire codebase.

============================

// File: ./price-balancer/src/main.rs
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::de::{self, Deserializer};
use serde::Deserialize;
use tokio::time::{sleep, Duration};

/// The Cheese mint on Solana
const CHEESE_MINT: &str = "A3hzGcTxZNSc7744CWB2LR5Tt9VTtEaQYpP6nwripump";

/// Meteora's paginated response
#[derive(Debug, Deserialize)]
struct PaginatedResponse {
    data: Vec<PoolInfo>,
    page: i32,
    total_count: i32,
}

// For fields that may be numeric strings
fn de_string_to_f64<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    s.parse().map_err(de::Error::custom)
}

/// Pool info from Meteora
#[derive(Debug, Deserialize)]
struct PoolInfo {
    pool_address: String,
    pool_name: String,
    pool_token_mints: Vec<String>,
    pool_type: String,
    total_fee_pct: String,
    unknown: bool,
    permissioned: bool,

    #[serde(deserialize_with = "de_string_to_f64")]
    pool_tvl: f64,

    #[serde(alias = "trading_volume")]
    daily_volume: f64,

    #[serde(default)]
    pool_token_amounts: Vec<String>,
}

/// For storing partial pool data with implied price
#[derive(Debug)]
struct CheesePoolPrice {
    pool_address: String,
    pool_name: String,
    price_usd: f64,
    fee_pct: f64,
    tvl: f64, // to identify < $600
}

/// A simple wallet struct
#[derive(Debug)]
struct Wallet {
    leftover_cheese: f64,
    leftover_other: f64, // Possibly we accumulate other tokens if we rebalanced
}

#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::new();
    let base_url = "https://amm-v2.meteora.ag/pools/search";

    let mut all_pools = Vec::new();
    let mut page = 0;
    let size = 50;

    // Step 1: fetch all Cheese pools
    loop {
        println!("Fetching page {}...", page);
        let resp = client
            .get(base_url)
            .query(&[
                ("page", page.to_string()),
                ("size", size.to_string()),
                ("include_token_mints", CHEESE_MINT.to_string()),
            ])
            .send()
            .await?;

        if !resp.status().is_success() {
            return Err(anyhow!("API request failed: {}", resp.status()));
        }

        let data: PaginatedResponse = resp.json().await?;
        println!("Got {} pools on page {}", data.data.len(), data.page);

        all_pools.extend(data.data);

        let fetched_so_far = (page + 1) * size;
        if fetched_so_far as i32 >= data.total_count {
            break;
        }
        page += 1;
    }

    println!(
        "\nFetched a total of {} Cheese pools from Meteora.\n",
        all_pools.len()
    );

    // A simple wallet
    let mut wallet = Wallet {
        leftover_cheese: 10000.0, // we have some cheese to start
        leftover_other: 0.0,      // or we track "other tokens" if we want
    };

    // Step 2: compute an implied price for each pool
    let mut pool_prices = Vec::new();
    for p in &all_pools {
        let fee_pct = p.total_fee_pct.parse::<f64>().unwrap_or(0.0);

        // placeholder logic for price
        let price_usd = if p.pool_tvl > 0.0 {
            p.pool_tvl / 500.0
        } else {
            0.0
        };

        pool_prices.push(CheesePoolPrice {
            pool_address: p.pool_address.clone(),
            pool_name: p.pool_name.clone(),
            price_usd,
            fee_pct,
            tvl: p.pool_tvl,
        });
    }

    // Step 3: find average price ignoring zeros
    let valid_prices: Vec<f64> = pool_prices
        .iter()
        .filter(|pp| pp.price_usd > 0.0)
        .map(|pp| pp.price_usd)
        .collect();

    let fair_price = if !valid_prices.is_empty() {
        let sum: f64 = valid_prices.iter().sum();
        sum / valid_prices.len() as f64
    } else {
        0.0
    };
    if fair_price == 0.0 {
        println!("No valid price => can't rebalance. Exiting...");
        return Ok(());
    }
    println!("Fair Cheese price is ~ ${:.4}", fair_price);

    // Step 4: Rebalance overpriced/underpriced pools
    for pp in &pool_prices {
        if pp.price_usd == 0.0 {
            continue;
        }
        let diff_pct = percent_diff(pp.price_usd, fair_price);
        if diff_pct <= pp.fee_pct {
            println!(
                "[{}] Price ${:.4}, diff {:.2}%, <= fee {:.2}%, skip",
                pp.pool_name, pp.price_usd, diff_pct, pp.fee_pct
            );
            continue;
        }

        // Decide a small trade
        let trade_size_cheese = 100.0;
        if pp.price_usd > fair_price {
            // overpriced => sell cheese
            println!(
                "[{}] Overpriced by {:.2}%. SELL cheese => leftover stable?",
                pp.pool_name, diff_pct
            );
            if wallet.leftover_cheese >= trade_size_cheese {
                wallet.leftover_cheese -= trade_size_cheese;

                let stable_gained = trade_size_cheese * pp.price_usd;
                // apply fee
                let actual_stable = stable_gained * (1.0 - pp.fee_pct / 100.0);
                // we store it as leftover_other in this example
                wallet.leftover_other += actual_stable;
            } else {
                println!("Not enough cheese to sell for rebalance.");
            }
        } else {
            // underpriced => buy cheese
            println!(
                "[{}] Underpriced by {:.2}%. BUY cheese => leftover stable spent?",
                pp.pool_name, diff_pct
            );
            // if we had stable, we could spend it. But let's skip in this example
        }
    }

    // Step 5: For pools under $600, deposit Cheese + "other token"
    // We'll find the ones with tvl < 600, sorted ascending
    let mut under_600: Vec<&CheesePoolPrice> =
        pool_prices.iter().filter(|pp| pp.tvl < 600.0).collect();
    under_600.sort_by(|a, b| {
        a.tvl
            .partial_cmp(&b.tvl)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    // We deposit in ascending order
    for pp in under_600 {
        // figure out how much we need to deposit to bring it up to $600
        let needed = 600.0 - pp.tvl;
        if needed <= 0.0 {
            continue;
        }
        println!(
            "[{}] TVL ${:.2} < $600 => deposit Cheese + other token to raise ~${:.2}",
            pp.pool_name, pp.tvl, needed
        );
        // In reality, you’d do a real deposit: we pair Cheese with the "unstable" asset
        // We assume we convert leftover_other to that "unstable" asset if needed.

        // For demonstration, let's deposit half Cheese, half "other"
        // So half in Cheese => needed/2 / price => how many cheese we deposit
        let half_needed = needed / 2.0;
        let cheese_deposit = half_needed / fair_price;
        if wallet.leftover_cheese < cheese_deposit {
            println!("Not enough cheese leftover to deposit in this pool. Skipping...");
            continue;
        }
        wallet.leftover_cheese -= cheese_deposit;

        // We also need an "other" deposit => let's see if leftover_other is enough
        // For demonstration, assume leftover_other is in USD value or convertible at 1:1
        if wallet.leftover_other < half_needed {
            println!("Not enough 'other' leftover to deposit. Skipping or partial deposit...");
            continue;
        }
        wallet.leftover_other -= half_needed;

        // We pretend we've deposited. TVL is ~600 now
        println!(
            " -> Deposited ~{:.2} Cheese & ${:.2} of other. Pool is near $600 now!",
            cheese_deposit, half_needed
        );
    }

    // Final summary
    println!(
        "\nFinal leftover Cheese: {:.2}, leftover Other: {:.2}",
        wallet.leftover_cheese, wallet.leftover_other
    );

    println!("Done balancing & depositing!");
    sleep(Duration::from_secs(2)).await;
    Ok(())
}

/// Return the absolute difference as a percentage of their average
fn percent_diff(a: f64, b: f64) -> f64 {
    if (a + b) == 0.0 {
        0.0
    } else {
        ((a - b).abs() * 200.0) / (a + b)
    }
}

============================

// File: ./cheese/src/updater.rs
// lib/src/updater.rs
//
// This module encapsulates the entire aggregator logic that was originally in
// update-readme/src/main.rs. We replicate that feature set: fetch from Meteora + Raydium,
// combine data, compute aggregates, print table, etc.

use anyhow::Result;
use reqwest::Client;
use std::collections::HashMap;
use tokio::time::{sleep, Duration};

use crate::{
    common::CHEESE_MINT,
    meteora::{fetch_meteora_cheese_pools, MeteoraPool},
    raydium::{fetch_raydium_cheese_pools, RaydiumDayStats, RaydiumPoolDetailed},
};

/// For the aggregator, we replicate the "DisplayPool", "CheeseAggregates" etc.
#[derive(Debug)]
pub struct DisplayPool {
    pub source: String, // "Meteora" or "Raydium"
    pub other_mint: String,
    pub other_symbol: String,
    pub cheese_qty: String,
    pub other_qty: String,
    pub pool_type: String,
    pub liquidity_usd: String,
    pub volume_usd: String,
    pub fee: String,
    pub pool_address: String,
}

#[derive(Debug, Default)]
pub struct CheeseAggregates {
    pub total_liquidity_usd: f64,
    pub total_volume_24h: f64,
    pub total_trades_all_time: u64,
    pub total_cheese_qty: f64,
}

/// The aggregator logic that fetches from both DEXes, merges, prints stats, table, etc.
pub async fn run_readme_updater() -> Result<()> {
    let client = Client::new();

    // 1) fetch from Meteora
    let meteora_pools = fetch_meteora_cheese_pools(&client).await?;

    // 2) fetch from Raydium
    let raydium_pools = fetch_raydium_cheese_pools(&client).await?;

    // 3) Possibly gather minted data. The original code also did Raydium "mint/ids",
    //    so you can do that here if you wish. We'll skip for brevity or do partial:
    //    (In the original code, you stored results in a map. We replicate as needed.)
    let mut mint_to_symbol = HashMap::new();
    // e.g. if you want to do some minted data queries, or just do fallback logic

    // 4) Convert meteora to DisplayPool
    let mut cheese_aggs = CheeseAggregates::default();
    let mut final_pools = Vec::new();

    for m in &meteora_pools {
        let (cheese_ix, other_ix) = if m.pool_token_mints.len() == 2 {
            if m.pool_token_mints[0] == CHEESE_MINT {
                (0, 1)
            } else {
                (1, 0)
            }
        } else {
            (0, 0)
        };

        let cheese_amt_str = m
            .pool_token_amounts
            .get(cheese_ix)
            .cloned()
            .unwrap_or_default();
        let other_amt_str = m
            .pool_token_amounts
            .get(other_ix)
            .cloned()
            .unwrap_or_default();

        let cheese_amt_f64 = cheese_amt_str.parse::<f64>().unwrap_or(0.0);
        let other_amt_f64 = other_amt_str.parse::<f64>().unwrap_or(0.0);

        let other_mint = m
            .pool_token_mints
            .get(other_ix)
            .cloned()
            .unwrap_or_default();
        let other_symbol = mint_to_symbol
            .get(&other_mint)
            .cloned()
            .unwrap_or_else(|| parse_other_token_name(&m.pool_name));

        cheese_aggs.total_liquidity_usd += m.pool_tvl;
        cheese_aggs.total_volume_24h += m.daily_volume;
        cheese_aggs.total_cheese_qty += cheese_amt_f64;
        cheese_aggs.total_trades_all_time += 1;

        final_pools.push(DisplayPool {
            source: "Meteora".to_string(),
            other_mint,
            other_symbol,
            cheese_qty: format!("{:.2}", cheese_amt_f64),
            other_qty: format!("{:.2}", other_amt_f64),
            pool_type: m.pool_type.clone(),
            liquidity_usd: format!("{:.2}", m.pool_tvl),
            volume_usd: format!("{:.2}", m.daily_volume),
            fee: m.total_fee_pct.clone(),
            pool_address: m.pool_address.clone(),
        });
    }

    // 5) Convert Raydium to DisplayPool
    for r in &raydium_pools {
        let (cheese_side_amt, other_side_amt, other_mint_addr, other_symbol) =
            if r.mintA.address == CHEESE_MINT {
                (
                    r.mint_amount_a,
                    r.mint_amount_b,
                    r.mintB.address.clone(),
                    r.mintB.symbol.clone(),
                )
            } else {
                (
                    r.mint_amount_b,
                    r.mint_amount_a,
                    r.mintA.address.clone(),
                    r.mintA.symbol.clone(),
                )
            };

        cheese_aggs.total_liquidity_usd += r.tvl;
        cheese_aggs.total_volume_24h += r.day.volume;
        cheese_aggs.total_cheese_qty += cheese_side_amt;
        cheese_aggs.total_trades_all_time += 2;

        final_pools.push(DisplayPool {
            source: "Raydium".to_string(),
            other_mint: other_mint_addr,
            other_symbol,
            cheese_qty: format!("{:.2}", cheese_side_amt),
            other_qty: format!("{:.2}", other_side_amt),
            pool_type: r.rtype.clone(),
            liquidity_usd: format!("{:.2}", r.tvl),
            volume_usd: format!("{:.2}", r.day.volume),
            fee: format!("{:.4}", r.feeRate),
            pool_address: r.pool_id.clone(),
        });
    }

    // Print aggregator stats
    println!("===== Cheese Aggregates =====");
    println!(
        "Total Liquidity (USD):   ${:.2}",
        cheese_aggs.total_liquidity_usd
    );
    println!(
        "Total 24H Volume (USD): ${:.2}",
        cheese_aggs.total_volume_24h
    );
    println!(
        "All-Time Trades:        {}",
        cheese_aggs.total_trades_all_time
    );
    println!(
        "Total Cheese qty:       {:.2}",
        cheese_aggs.total_cheese_qty
    );
    println!("=============================\n");

    // Print the table
    print_table(&final_pools);

    sleep(Duration::from_secs(2)).await;
    Ok(())
}
fn parse_other_token_name(pool_name: &str) -> String {
    let parts: Vec<&str> = pool_name.split('-').collect();
    if parts.len() == 2 {
        let left = parts[0].trim();
        let right = parts[1].trim();
        if left.contains("🧀") || left.to_lowercase().contains("cheese") {
            return right.to_string();
        }
        if right.contains("🧀") || right.to_lowercase().contains("cheese") {
            return left.to_string();
        }
        return right.to_string();
    }
    pool_name.to_string()
}

fn print_table(pools: &[DisplayPool]) {
    println!(
        "| {:<8} | {:<44} | {:<10} | {:>10} | {:>10} | {:<10} | {:>12} | {:>12} | {:>5} | {:<44} |",
        "Source",
        "Other Mint",
        "Symbol",
        "Cheese Qty",
        "Other Qty",
        "Pool Type",
        "Liquidity($)",
        "Volume($)",
        "Fee",
        "Pool Address",
    );

    println!(
        "|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|",
        "-".repeat(8),
        "-".repeat(44),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(12),
        "-".repeat(12),
        "-".repeat(5),
        "-".repeat(44),
    );

    for dp in pools {
        println!(
            "| {:<8} | {:<44} | {:<10} | {:>10} | {:>10} | {:<10} | {:>12} | {:>12} | {:>5} | {:<44} |",
            dp.source,
            truncate(&dp.other_mint, 44),
            truncate(&dp.other_symbol, 10),
            dp.cheese_qty,
            dp.other_qty,
            truncate(&dp.pool_type, 10),
            dp.liquidity_usd,
            dp.volume_usd,
            dp.fee,
            truncate(&dp.pool_address, 44),
        );
    }
}

fn truncate(input: &str, max_len: usize) -> String {
    if input.len() <= max_len {
        input.to_string()
    } else {
        format!("{}…", &input[..max_len.saturating_sub(1)])
    }
}

============================

// File: ./cheese/src/lib.rs
pub mod common;
pub mod meteora;
pub mod raydium;
pub mod updater;

============================

// File: ./cheese/src/raydium.rs
// lib/src/raydium.rs
//
// Logic + data models for Raydium
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Deserialize;

use crate::common::CHEESE_MINT;

#[derive(Debug, Deserialize)]
pub struct RaydiumMintPoolsResponse {
    pub id: String,
    pub success: bool,
    pub data: RaydiumMintPoolsData,
}

#[derive(Debug, Deserialize)]
pub struct RaydiumMintPoolsData {
    pub count: u64,
    #[allow(non_snake_case)]
    pub hasNextPage: bool,
    pub data: Vec<RaydiumPoolDetailed>,
}

#[derive(Debug, Deserialize)]
pub struct RaydiumPoolDetailed {
    #[serde(default, alias = "type")]
    pub rtype: String,

    #[serde(default)]
    pub programId: String,

    #[serde(default, alias = "id")]
    pub pool_id: String,

    #[serde(default)]
    pub mintA: RaydiumMintItem,

    #[serde(default)]
    pub mintB: RaydiumMintItem,

    #[serde(default)]
    pub price: f64,
    #[serde(default, alias = "mintAmountA")]
    pub mint_amount_a: f64,
    #[serde(default, alias = "mintAmountB")]
    pub mint_amount_b: f64,

    #[serde(default)]
    pub feeRate: f64,

    #[serde(default)]
    pub openTime: String,

    #[serde(default)]
    pub tvl: f64,

    #[serde(default)]
    pub day: RaydiumDayStats,
}

#[derive(Debug, Deserialize, Default)]
pub struct RaydiumDayStats {
    #[serde(default)]
    pub volume: f64,
}

#[derive(Debug, Deserialize)]
pub struct RaydiumMintItem {
    #[serde(default)]
    pub address: String,
    #[serde(default)]
    pub symbol: String,
}

/// Fetch Raydium pools containing cheese
pub async fn fetch_raydium_cheese_pools(client: &Client) -> Result<Vec<RaydiumPoolDetailed>> {
    let url = format!(
        "https://api-v3.raydium.io/pools/info/mint?mint1={}&poolType=all&poolSortField=default&sortType=desc&pageSize=1000&page=1",
        CHEESE_MINT
    );
    println!("Requesting Raydium cheese pools from {url}");

    let resp = client.get(&url).send().await?;
    if !resp.status().is_success() {
        return Err(anyhow!("Raydium request failed: {}", resp.status()));
    }

    let parsed: RaydiumMintPoolsResponse = resp.json().await?;
    if !parsed.success {
        return Err(anyhow!(
            "Raydium cheese-pools returned success=false for id {}",
            parsed.id
        ));
    }

    println!(
        "Raydium /pools/info/mint returned {} items\n",
        parsed.data.count
    );
    Ok(parsed.data.data)
}

============================

// File: ./cheese/src/balancer.rs
// lib/src/balancer.rs
//
// This module encapsulates the entire "price-balancer" logic that was originally in
// price-balancer/src/main.rs. We replicate that feature set and data flow here, so
// that the main file can remain minimal.

use anyhow::{anyhow, Result};
use reqwest::Client;
use tokio::time::{sleep, Duration};

use crate::{
    common::{percent_diff, CHEESE_MINT},
    meteora::{fetch_meteora_cheese_pools, MeteoraPool},
};

/// A simple "wallet" struct to track leftover cheese & stable
#[derive(Debug)]
pub struct Wallet {
    pub leftover_cheese: f64,
    pub leftover_other: f64,
}

/// A smaller struct for storing partial pool data
#[derive(Debug)]
struct CheesePoolPrice {
    pool_address: String,
    pool_name: String,
    price_usd: f64,
    fee_pct: f64,
    tvl: f64,
}

/// The main rebalancing function, replicating all steps from the original price-balancer main
/// (fetch, compute implied prices, rebalancing trades, etc.).
pub async fn run_price_balancer() -> Result<()> {
    let client = Client::new();
    let mut wallet = Wallet {
        leftover_cheese: 10_000.0,
        leftover_other: 0.0,
    };

    // Step 1: fetch all Cheese pools from Meteora
    let all_pools: Vec<MeteoraPool> = fetch_meteora_cheese_pools(&client).await?;
    println!(
        "\nFetched a total of {} Cheese pools from Meteora.\n",
        all_pools.len()
    );

    // Step 2: compute an implied price for each pool
    let mut pool_prices = Vec::new();
    for p in &all_pools {
        let fee_pct = p.total_fee_pct.parse::<f64>().unwrap_or(0.0);

        // placeholder logic for price
        let price_usd = if p.pool_tvl > 0.0 {
            p.pool_tvl / 500.0
        } else {
            0.0
        };

        pool_prices.push(CheesePoolPrice {
            pool_address: p.pool_address.clone(),
            pool_name: p.pool_name.clone(),
            price_usd,
            fee_pct,
            tvl: p.pool_tvl,
        });
    }

    // Step 3: find average price ignoring zeros
    let valid_prices: Vec<f64> = pool_prices
        .iter()
        .filter(|pp| pp.price_usd > 0.0)
        .map(|pp| pp.price_usd)
        .collect();

    let fair_price = if !valid_prices.is_empty() {
        let sum: f64 = valid_prices.iter().sum();
        sum / valid_prices.len() as f64
    } else {
        0.0
    };
    if fair_price == 0.0 {
        println!("No valid price => can't rebalance. Exiting...");
        return Ok(());
    }
    println!("Fair Cheese price is ~ ${:.4}", fair_price);

    // Step 4: Rebalance overpriced/underpriced pools
    for pp in &pool_prices {
        if pp.price_usd == 0.0 {
            continue;
        }
        let diff_pct = percent_diff(pp.price_usd, fair_price);
        if diff_pct <= pp.fee_pct {
            println!(
                "[{}] Price ${:.4}, diff {:.2}%, <= fee {:.2}%, skip",
                pp.pool_name, pp.price_usd, diff_pct, pp.fee_pct
            );
            continue;
        }

        let trade_size_cheese = 100.0;
        if pp.price_usd > fair_price {
            // overpriced => SELL cheese
            println!(
                "[{}] Overpriced by {:.2}%. SELL cheese => leftover stable?",
                pp.pool_name, diff_pct
            );
            if wallet.leftover_cheese >= trade_size_cheese {
                wallet.leftover_cheese -= trade_size_cheese;

                let stable_gained = trade_size_cheese * pp.price_usd;
                // apply fee
                let actual_stable = stable_gained * (1.0 - pp.fee_pct / 100.0);
                wallet.leftover_other += actual_stable;
            } else {
                println!("Not enough cheese to sell for rebalance.");
            }
        } else {
            // underpriced => BUY cheese
            println!(
                "[{}] Underpriced by {:.2}%. BUY cheese => leftover stable spent?",
                pp.pool_name, diff_pct
            );
            // if we had stable, we would spend it. We'll skip in this example
        }
    }

    // Step 5: For pools under $600, deposit Cheese + "other token"
    let mut under_600: Vec<&CheesePoolPrice> =
        pool_prices.iter().filter(|pp| pp.tvl < 600.0).collect();
    under_600.sort_by(|a, b| {
        a.tvl
            .partial_cmp(&b.tvl)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    for pp in under_600 {
        let needed = 600.0 - pp.tvl;
        println!(
            "[{}] TVL ${:.2} < $600 => deposit Cheese + other token to raise ~${:.2}",
            pp.pool_name, pp.tvl, needed
        );
        let half_needed = needed / 2.0;
        let cheese_deposit = half_needed / fair_price;
        if wallet.leftover_cheese < cheese_deposit {
            println!("Not enough cheese leftover. Skipping...");
            continue;
        }
        wallet.leftover_cheese -= cheese_deposit;

        if wallet.leftover_other < half_needed {
            println!("Not enough 'other' leftover. Skipping or partial deposit...");
            continue;
        }
        wallet.leftover_other -= half_needed;

        println!(
            " -> Deposited ~{:.2} Cheese & ${:.2} of other => new TVL ~600",
            cheese_deposit, half_needed
        );
    }

    // Final summary
    println!(
        "\nFinal leftover Cheese: {:.2}, leftover Other: {:.2}",
        wallet.leftover_cheese, wallet.leftover_other
    );

    println!("Done balancing & depositing!\n");
    sleep(Duration::from_secs(2)).await;
    Ok(())
}

============================

// File: ./cheese/src/meteora.rs
// lib/src/meteora.rs
//
// Logic + data models for interacting with Meteora
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Deserialize;

use crate::common::{de_string_to_f64, CHEESE_MINT};

#[derive(Debug, Deserialize)]
pub struct PaginatedPoolSearchResponse {
    pub data: Vec<MeteoraPool>,
    pub page: i32,
    pub total_count: i32,
}

#[derive(Debug, Deserialize)]
pub struct MeteoraPool {
    pub pool_address: String,
    pub pool_name: String,
    pub pool_token_mints: Vec<String>,
    pub pool_type: String,
    pub total_fee_pct: String,

    #[allow(dead_code)]
    pub unknown: bool,
    #[allow(dead_code)]
    pub permissioned: bool,

    #[serde(deserialize_with = "de_string_to_f64")]
    pub pool_tvl: f64,

    #[serde(alias = "trading_volume")]
    pub daily_volume: f64,

    #[serde(default)]
    pub pool_token_amounts: Vec<String>,
}

/// Fetch all Cheese pools from the Meteora endpoint
pub async fn fetch_meteora_cheese_pools(client: &Client) -> Result<Vec<MeteoraPool>> {
    let base_url = "https://amm-v2.meteora.ag";
    let search_url = format!("{}/pools/search", base_url);

    let mut all_pools = Vec::new();
    let mut page = 0;
    let size = 50;

    loop {
        println!("Requesting page {page} from {search_url}");
        let resp = client
            .get(&search_url)
            .query(&[
                ("page", page.to_string()),
                ("size", size.to_string()),
                ("include_token_mints", CHEESE_MINT.to_string()),
            ])
            .send()
            .await?;

        if !resp.status().is_success() {
            return Err(anyhow!("Meteora request failed: {}", resp.status()));
        }

        let parsed: PaginatedPoolSearchResponse = resp.json().await?;
        println!(
            "Got {} pools on page {}, total_count={}",
            parsed.data.len(),
            parsed.page,
            parsed.total_count
        );

        all_pools.extend(parsed.data);

        let fetched_so_far = ((page + 1) * size) as i32;
        if fetched_so_far >= parsed.total_count {
            break;
        }
        page += 1;
    }

    println!(
        "\nFetched a total of {} Cheese pools from Meteora.\n",
        all_pools.len()
    );
    Ok(all_pools)
}

============================

// File: ./cheese/src/common.rs
// lib/src/lib.rs
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::de::{self, Deserializer};
use serde::Deserialize;
use std::collections::HashSet;

pub const CHEESE_MINT: &str = "A3hzGcTxZNSc7744CWB2LR5Tt9VTtEaQYpP6nwripump";

// ---------- Data Models from your prior code ----------

#[derive(Debug, Deserialize)]
pub struct PaginatedResponse {
    pub data: Vec<PoolInfo>,
    pub page: i32,
    pub total_count: i32,
}

#[derive(Debug, Deserialize)]
pub struct PoolInfo {
    pub pool_address: String,
    pub pool_name: String,
    pub pool_token_mints: Vec<String>,
    pub pool_type: String,
    pub total_fee_pct: String,
    pub unknown: bool,
    pub permissioned: bool,

    #[serde(deserialize_with = "de_string_to_f64")]
    pub pool_tvl: f64,

    #[serde(alias = "trading_volume")]
    pub daily_volume: f64,

    #[serde(default)]
    pub pool_token_amounts: Vec<String>,
}

// Helper so we can share it
pub fn de_string_to_f64<'de, D>(deserializer: D) -> std::result::Result<f64, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    s.parse().map_err(de::Error::custom)
}

// ---------- Shared logic: fetch_meteora_cheese_pools ----------

pub async fn fetch_meteora_cheese_pools(client: &Client) -> Result<Vec<PoolInfo>> {
    let base_url = "https://amm-v2.meteora.ag/pools/search";

    let mut all = Vec::new();
    let mut page = 0;
    let size = 50;

    loop {
        println!("Fetching page {} from Meteora...", page);
        let resp = client
            .get(base_url)
            .query(&[
                ("page", page.to_string()),
                ("size", size.to_string()),
                ("include_token_mints", CHEESE_MINT.to_string()),
            ])
            .send()
            .await?;

        if !resp.status().is_success() {
            return Err(anyhow!(
                "Meteora /pools/search request failed: {}",
                resp.status()
            ));
        }

        let parsed: PaginatedResponse = resp.json().await?;
        println!(
            "Got {} pools on page {}, total_count={}",
            parsed.data.len(),
            parsed.page,
            parsed.total_count
        );

        all.extend(parsed.data);

        let fetched_so_far = ((page + 1) * size) as i32;
        if fetched_so_far >= parsed.total_count {
            break;
        }
        page += 1;
    }

    println!(
        "\nFetched a total of {} Cheese pools from Meteora.\n",
        all.len()
    );
    Ok(all)
}

// Example shared helper: returns the absolute diff % between two numbers
pub fn percent_diff(a: f64, b: f64) -> f64 {
    if (a + b) == 0.0 {
        0.0
    } else {
        ((a - b).abs() * 200.0) / (a + b)
    }
}

============================

// File: ./update-readme/Readme.md
# Update-Readme


## Sample Output:


| Other Mint                                   | Other Name | Pool Type  | Liquidity($) |    Volume($) |   Fee | Pool Address                                 |
|----------------------------------------------|------------|------------|--------------|--------------|-------|----------------------------------------------|
| DVZrNS9fctrrDmhZUZAu6p63xU6d9cqYxRRhJbtJ4z8G | Ross       | volatile   |      1471.18 |       994.11 |     6 | FupaG32pfMTpMhTkqwECJLnkubyDbK6SyuRnLTCV8DVy |
| EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v | USDC       | volatile   |       635.55 |       752.02 |  0.25 | 2rkTh46zo8wUvPJvACPTJ16RNUHEM9EZ1nLYkUxZEHkw |
| 8Q9VDdrd1rNczTEL3ivPhwsYrYXVuSAdHuY7gFJGpump | heheh      | volatile   |      1212.42 |       537.52 |     6 | 7qsfntxehFARLJraX21F76DMjUp9ymJTVQWk2xYs6HKZ |
| UwU8RVXB69Y6Dcju6cN2Qef6fykkq6UUNpB15rZku6Z  | UWU        | volatile   |       721.83 |       296.89 |     6 | 6iKJ7myS3SqUbeYbXfLVw8adofDe8uaeEwhULL5ksKf1 |
| DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263 | Bonk       | volatile   |       591.88 |       294.55 |     6 | B2rNswUmxGGjLkeeV9Y8ieVGa12oQ5hFwmgYn8NhnFXf |
| DEf93bSt8dx58gDFCcz4CwbjYZzjwaRBYAciJYLfdCA9 | KWEEN      | volatile   |       462.72 |       246.32 |     6 | HPjuz4Xf4y7eqc66b8jRX3zZJXjuMUTCcJTsE27vWBEV |
| CTJf74cTo3cw8acFP1YXF3QpsQUUBGBjh2k2e8xsZ6UL | Neiro      | volatile   |       476.50 |       241.41 |     6 | 5eio6VxNoE1Vxi8cyTziZ34e19Cqr9rS2PNTNUSXM1Lc |
| oreoU2P8bN6jkk3jbaiVxYnG1dCXcYxwhwyK9jSybcp  | ORE        | volatile   |       540.85 |       238.92 |     6 | JCADLh6Ed82VppT6og9NwadLSeAJRLVKDwWQXSaco7BK |
| 7iagMTDPfNSR5zVcERT1To7A9eaQoz58dJAh42EMHcCC | YAKUB      | volatile   |       330.86 |       150.12 |     6 | GJD4FtQVhRFQi4niknXYgKpuqWaUcmMEjzUNTUv26fu7 |
| BJbG7wFjv1qxdJfUQCLhzKZCp89jCd3EpseogAvWmBQv | NSA        | volatile   |       324.89 |       147.68 |     6 | NmqKNmykva9tMtXEQUtW14vSWQFw9g4vCNXX7Nih4DR  |
| DAFdakKAEvB6GtJgnDk1LC1QK4gQrtTK3eKUZtAJpump | PSYOP      | volatile   |       346.65 |       146.36 |     6 | 9vaQ2BiN56HmxtBQ42rL2mbdaCriKj24mB8xvicVwfSy |
| CzLSujWBLFsSjncfkh59rUFqvafWcY5tzedWJSuypump | GOAT       | volatile   |       282.08 |       140.72 |     6 | HWYbW1VtF6scSrUQ8P8HJAfCd1pjhPjfNM8qCsrXsqqD |
| 9pWPUXoZKWNPWyaegPQeR3Kn8aFz9nrGtm5jeAFzpump | WMM        | volatile   |       301.64 |       137.12 |     6 | 8YDPSMxocxCyGUmS9E8aR7ESPj9kkD36qWrtg8u8NMzN |
| 4J5HoZWoKcbo2JQxEEVCKRBfUQtEroY1QdRrKtZFpump | IB         | volatile   |       288.57 |       134.86 |     6 | 8GegNfRq8PYvVVHNi56g5wfRrgHu59fyyYqHBTKstkwe |
| 6ogzHhzdrQr9Pgv6hZ2MNze7UrzBMAFyBBWUYp1Fhitx | RETARDIO   | volatile   |       365.17 |       133.93 |     6 | D8qndp6bj9jHjCp41mcT7tS8dPz8rKsF7L68mfUma44v |
| CBdCxKo9QavR9hfShgpEBG3zekorAeD7W1jfq2o3pump | LUCE       | volatile   |       240.46 |       128.84 |     4 | HpqFih2qxGV4SYiHmZLCea4W3vuFFCmyY68sxEFAUmaz |
| 3DkVGaNSMTcxFkgGDAm299FaVxgnCw2411vxZTmRpump | OMEGA      | volatile   |       209.51 |       113.81 |     6 | GhFnkKAishxyjiexCcWEdXu9icCspCoqhtVbkp64Si84 |
| AbrMJWfDVRZ2EWCQ1xSCpoVeVgZNpq1U2AoYG98oRXfn | Cheese     | volatile   |       248.10 |       106.83 |     6 | 315qCqiL5Fugm77Ww34jmpXe1JnDjoogGMS3aZ4S1CAw |
| 9vrGUHwsC8LyLjQoh3zJb9S53x7A88u49La63qPB6F5t | lilpump    | volatile   |       221.44 |       102.99 |     6 | AuSTCp82gbbN1imu869RucyhXjX3qNgaR3v7bunNXcLn |
| CTgiaZUK12kCcB8sosn4Nt2NZtzLgtPqDwyQyr2syATC | BITCOIN    | volatile   |       254.97 |        96.90 |     6 | 2zaSHDLWKn64pA6fYaTWVm1SWcc4hKpRt8qpEZDKXQP8 |
| 7dGbPgUxKpB5qWiLRKcTQSC3om1fPzUpgGAFfwej9hXx | GCR        | volatile   |       238.75 |        95.43 |     6 | CdxCb7krK9GFWghkb6phR7SJhdFZ5hY6jU4PfXM9vMrX |
| B5WTLaRwaUQpKk7ir1wniNB6m5o8GgMrimhKMYan2R6B | Pepe       | volatile   |       225.72 |        94.94 |     6 | FuT2xognvqkSYu2sUHLRU8iaj3Rjb4NgyWDMJj7eHuZh |
| 2qEHjDLDLbuBgRYvsxhc5D6uDWAivNFZGan56P1tpump | Pnut       | volatile   |       229.15 |        87.13 |     6 | 6S6NNse5dZWdm841QLLcuMt6hkNybr7ULqzgh23Q8wkw |
| 69G8CpUVZAxbPMiEBrfCCCH445NwFxH6PzVL693Xpump | xavier     | volatile   |       221.98 |        84.32 |     6 | AkdXiSK2RekFcGsuLvVpWaAeh5tioLJxrihzNTPXfWr  |
| EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm | $WIF       | volatile   |       200.09 |        69.93 |     6 | ERSxacWnUDUYybGSEhQAYvf29vyNQiSRArBcBD2oqYJJ |
| CNvitvFnSM5ed6K28RUNSaAjqqz5tX1rA5HgaBN9pump | FRED       | volatile   |       133.84 |        64.09 |     6 | Dne9QjdhRXxAiRYCnhANGbwUip9grqnqNPLLNyMpPNKT |
| 9wBNNCXg8pb4SZpTY868CEr74S25Qy1JmGHFwo9F37dC | sugar      | volatile   |         4.81 |         1.25 |     6 | 6ozXSmmUUUdGhjyLWUmzohRJVDva12NJELdqAz8GxBUa |
| 3G5t554LYng7f4xtKKecHbppvctm8qbkoRiTtpqQEAWy | Empire     | volatile   |         0.00 |         0.00 |  0.25 | 9i3XtbqMnRRuRF4VHaKyhPVxxS9jododcYdjjGSPqape |
| 3G5t554LYng7f4xtKKecHbppvctm8qbkoRiTtpqQEAWy | Empire     | volatile   |         0.00 |         0.00 |     2 | 7GgkvrCDBETTpxxUqLugRhxRCCajnxx8aq6HBxTb7iKX |
| 97y1UnhmnE16h4tT2jKXC3Zivr6Fw1abHbrYXQWpump  | CRYPTO     | volatile   |         0.00 |         0.00 |     6 | 8ZKMj8PQTrKfJGccD3hBC1GBnfot1JBUDFeJWYsfnpr9 |
| Dp3EydLyxydf69ACzXtJb9tcq67235d4vEnLB8dRpump | PLEIADES   | volatile   |         0.00 |         0.00 |     6 | F2rHaxpSPMLg1ssj7gZPVto1KAxFTdphrmDbDMWPh3Vq |
| HQXwjVBUU2fvvrM7xNq6gfX3vsACkqHtZo7mwKwUpump | 🪲          | volatile   |         0.00 |         0.00 |     6 | 6cr225nS4XYaHh8cRWZYwXUg7jvumnpSRQstuBLtv5Mj |
| whheYm7JzA2DsAofFKvXtNdJ8HhQDxa72fa52pdHaoB  | ❤          | volatile   |         0.00 |         0.00 |     6 | H93He4vTuXdvnRV6aLa27XheKbdw7Lp5vvCkTUw6Hre5 |
| 2pt5uJt9zJM8CxDBW4PjJ4ZCgPSVeg5kWbbub95vpump | 🍕          | volatile   |         0.00 |         0.00 |  0.25 | 8yaej1DUDhPo8pDbXZuqc5x4hcYFy73918VnESUDjaj6 |
| Gyb6MUj5wyR4h5GkNZ9rUU5Ce5jbcunC2QUPUvXepump | CHILLDATE  | volatile   |         0.00 |         0.00 |     1 | 9x5G1as3ZGKv37qxA75Jz3yds1YJTBR9Yu66nzS5owua |
| GtDTpas1uhARVnCWfaV4Jbx7WdC1wem8xNvMT5fYpump | buttgun    | volatile   |         0.00 |         0.00 |  0.25 | 3TzWS9kQYeNHuLt5mL4eYNDkAonpmcFnspFSaE4Rjjz6 |
| 27VkFr6b6DHoR6hSYZjUDbwJsV6MPSFqPavXLg8nduHW | OSHO       | volatile   |         0.00 |         0.00 |  0.25 | 2KV1nqPbcrpg6hMMMxer1m3UsjAmQiF4ZZzdfR1jP6aD |
| AdJ7FFvw7Yo7LzKbcFuRpNqScLQr54FW9mE5ZatACvcJ | aiDAOvc    | volatile   |         0.00 |         0.00 |     1 | 4mK6t5DPsoDt9jBs2jhCmyiPvytuvUpXXGyBisJhBjCY |
| C9BAWUXTCtCMXsmzvAH4qST3bPF2vUVKw3MLKbGqpump | 🍑          | volatile   |         0.00 |         0.00 |     6 | 4s6Zkk5JABmkTfY9djkcA8fKXRUPRqSNBqTgVD55PXxp |
| B6a5SKQt3Mtoq9HcPq7PdNPfG8Sq1S2ywqdYfWjJpump | 🏴          | volatile   |         0.00 |         0.00 |     6 | 6QN3TNzNxzQ7cVt2ELLVMZpKPqc6KAJn27RFssPPF2Y7 |
| CiArTh5ZDuhh5WaLsU7Yiga2By3RZxy3tfwimu36pump | 🐿          | volatile   |         0.00 |         0.00 |     6 | 9MjsRxDsnXzTGDCBhkk7YjJQbr6T1So3Rg7JGjRFwP36 |
| 65GVcFcSqQcaMNeBkYcen4ozeT83tr13CeDLU4sUUdV6 | LAWB       | volatile   |         0.00 |         0.00 |     6 | 8p6MsN8eLPGPx1YkPGkzVUf42DYCWyXPFcTrtCtvYLr9 |
| 82owMeqrf69bSHC1qLW1S9FLb6RCV42A1ASnz4PMtXoW | POLKADOT   | volatile   |         0.00 |         0.00 |     6 | Fr1SepFjDqm4diSFs4FANBuWgxF8443uzc6JF77f7XgJ |
| GAnbsFco9V7VDbm4CNECGezSjvoe9UQqz8NzEoKgqDa9 | $goatse    | volatile   |         0.00 |         0.00 |     6 | 12mCkbK5jMt3BikoqtBpSc9FRLRMqA9WsX4XNcypP1Qc |
| 5BKw97mLkc3HyZY88ZjigiXbaqiGFzDbHHQCdCGpump  | MOMO       | volatile   |         0.00 |         0.00 |     6 | HK7TJFBZeCVSeEyW3AmEUKHZ1QBuCg7HREnERvE4Xoc1 |
| AbktLHcNzEoZc9qfVgNaQhJbqDTEmLwsARY7JcTndsPg | MS2        | volatile   |         0.00 |         0.00 |     6 | E31ayfdLzoe61VEhzkSegTfExUgbKyEJgqU5qdvvDcDL |
| 5HRdK5xnCo4pZDCsyR9RcUXqYyEVvvmTUNA9y6Wopump | BIGPIG     | volatile   |         0.00 |         0.00 |     6 | 8J5JkNK5yqDa8jCcAFrqWiiCkAaYovPVt73fiSwX1inm |
| 6WJe5ov7oDkFKgyiGbA19SrX5iGfCR2Mmq9kiGvpLYYd | FEMBRO     | volatile   |         0.00 |         0.00 |     6 | EJmcSKfGA7GQyBU1wd8rUFFz2bYaQfv2JUKNqu9YEJPZ |
| Fr11i9wEwFKEW2os79rwDFsFtwU63GWxSGwmtpjSpump | LAIN       | volatile   |         0.00 |         0.00 |     6 | Hk39URemXU5FFHXrThZurN2NEULuDKJxwyntrP6nPyyu |
| 5hQvD2F5DRNTcZGniDqU4HHZh4HZjapRg4aWAPFsRKmG | fella      | volatile   |         0.00 |         0.00 |     6 | BMfnU5QfZdNXuvN3dJCmM7QRAnN2gN1upGU2H7Y4qF2X |
| AfXRqsG4PhEJyXfNiqeZf9cWVNkSA9YannF1ttvP9fsm | YTHO       | volatile   |         0.00 |         0.00 |     6 | FY4YrsGQv8Fg8DfHCNCwNjnEbYANoYisqXZa2ntmQPBS |
| 46SJKxbS5BWFBdGWx9fyNHTXQih9eiUPjsS6FHjqpump | 🥩          | volatile   |         0.00 |         0.00 |     6 | DFaAcU2Q1VN4XAcJm3chvyM795v7NaqAYoAFd6gJwHZC |
| 8TxrPTHjtVnsZpJAbbxucVArFwhyAqFHVkLiCYHSpump | $🍔         | volatile   |         0.00 |         0.00 |     6 | 7LW4S27hLUK2RiroscDFqqGzibebjKxdqxPHfRmMLLuL |
| HKe2m743UEekUgiZErKp3WK4YD4jDJzFmeeY4WHBpump | MSD        | volatile   |         0.00 |         0.00 |     6 | HUp297H7JzHncaTDu2RcCtD2scALwWUszy4R4Yvnojip |
| J7HcmMsExg5o6TB6sL3aTz8LUWKtXxqj82AkFzXFpump | Girajelly  | volatile   |         0.00 |         0.00 |     6 | 98SNgzCrdyBDF1tdaMm1zewGbkbRCWMw2pdkB7VGSPd8 |
| 5qAWPGkRqb9aV7Yox4gfbJTbm1a9msaswKxyCirwpump | PUSSY      | volatile   |         0.00 |         0.00 |     6 | J5rhwQcvDCXZqJLcWFmxPto8c1z8LBDHFU9qiBde9YUT |
| 6PbjXML6yTzjJD1ex7sGrXGbDAxTzRQsh9xEcVKQpump | thin       | volatile   |         0.00 |         0.00 |     6 | CwakjJRDCVHWW58DEjTr4ZqvgbpsdaKEVxX1ggNvF4F6 |
| DQKA8ohLLiAoES8BXvBswbQ1DefnkZTqvNnnHbbGpump | $CST       | volatile   |         0.00 |         0.00 |     6 | A1nyWrQnngNCXbQrfQCZi4yzM3N79Bhet6fnH2h2PE76 |
| 3E2z4KX7y457xJqK9RQeJhA29oPdoUvAAD3Ea3zQyuG3 | OX         | volatile   |         0.00 |         0.00 |     1 | 7zEZe3FPb8RcAEojffmZe6nfqrygijx4VjfRuYVepSrm |
| DPgYSEECreJTG9dTei6tqhryCkf9f23cibTcNNtfpump | POOL       | volatile   |         0.00 |         0.00 |     6 | 83uVzF3a83y5H3ExrUcTR9VznZjeCuiNNBW2JQyrCBXG |
| GF4mRrsd52LHBZ4Fj9ijEwHCnh7c2wTMwDKwZQqipump | LINK       | volatile   |         0.00 |         0.00 |     6 | 5GzQPLxDU5r7i5jNbjXzosTsU6WoDF5yXabbAgiZ5LGe |
| 8unVvwASRwZPJP6YRkpD4kTrrwKLyw8zS1yyHFadpump | ETH        | volatile   |         0.00 |         0.00 |     6 | AjrFrJ8wxQGv4XPoqhUCZ8JM7NnMp6LNEWXCFeRdM3M2 |
| 2kaRSuDcz1V1kqq1sDmP23Wy98jutHQQgr5fGDWRpump | ETH        | volatile   |         0.00 |         0.00 |     6 | H2xbVL7a7nDB3LDhHtHCsJdiX1brSCxvnFrWLbbLa4FG |
| E3Ya9KyGW2Jy2HofY6Xvghmhs7ki4ezAhVpbsTG4pump | rave       | volatile   |         0.00 |         0.00 |     6 | 2vMVjjFdwUNwbn9Kq45hnai45eCmw6SvBqzhHSb4VqGx |
| F8btFvgEKbsBvgornHg7Yb4QUgtceiyFeEaMZVQopump | Patchouli  | volatile   |         0.00 |         0.00 |     6 | 5Ta8zrvzwNTy8PLZ7hyegjrefWNpozZbecwpVo7A41AP |
| 42ZiZ9vA8L6BKcJMi4SjebKsgisyEyztBdYn646Ppump | PFF        | volatile   |         0.00 |         0.00 |     6 | JAhbjNf8UXvrWfZzn3JoiLsVMu6bM259MYg9bKNFBtz7 |
| 8YYrkf1hvL5aCacfLXDvhVfjWZ7ce5NdVt4iLPxYsmdh | bbydev     | volatile   |         0.00 |         0.00 |     6 | 9ANG2LzWE3jNfjESRdzZFqWrTTubdhNUf2HMFKHF8ENa |
| HCy1DWLpYGGzbxt869upnCWv1WPQjwsEdGmq3Gfn88zf | Nucel      | volatile   |         0.00 |         0.00 |     6 | 9B5E924eqvbqbTrSckNr7n8pdWETXowuCxxaM57m3Qxh |
| 6UtoreGfFcwrBKhSgfzwBVpL5ZQ333q23gK5FoHipump | RUPERT     | volatile   |         0.00 |         0.00 |     6 | AwX8p5SciTZV3rT6GpJCatqLTi6qg8F5NWF3nQHgy48T |
| 7HW7JWmXKPf5GUgfP1vsXUjPBy7WJtA1YQMLFg62pump | Hara       | volatile   |         0.00 |         0.00 |     6 | AggYEnguDtREyNFj3vHLTo85orAo4tqPJ1rT4Gpk84Vq |
| HKi48qfNYAKmVCmW45D4atKMJ1dcBFJjSJzybjULpump | Muradio    | volatile   |         0.00 |         0.00 |     6 | 9iAsNofTaLC7pW11oq6nPnQxBamQeRNujYYXwpqo8hwC |
| GrLAhK5FUHurJVhoJ1XDp46MKskERuAs7Jqimheppump | DOGGO      | volatile   |         0.00 |         0.00 |     6 | HHhQHeu2k9tFTYJCCCPpkEYJ5zXgdBrNWBotx1y924Mf |
| HeWdnJqjmmFbs6ACUHuPTR8diasBjNRiyKumFvyypump | ber        | volatile   |         0.00 |         0.00 |     6 | 2biW1KVzAXrqdtgswiEJG87YsEFnUR7bzH8H4F4imWEc |
| 7eFYS4gvKR9CxsXsYx9iM9RFFzykNfXCCqvmsv2wpump | greg       | volatile   |         0.00 |         0.00 |     6 | B7Dpjbm53h7kRLFiVXPLyCt6FU1vqSzFkZTFVDEzkeuW |
| JDjprgWYuidVGfExWzMp7Z81K3T6Qsg5aJCnG6srRLGW | BOL        | volatile   |         0.00 |         0.00 |     6 | 7HGjqwMbfiXp8QzbKvwyKnkuWn3ufPRDiRFnFzZts7Gx |
| ENLioptrHdhNKvdhKMWJqFwhhPvacB5VtpaDTYvNpump | OG         | volatile   |         0.00 |         0.00 |     6 | HDbDVSFPziJSUMS8578fB1jdm86JAPMUbCFYCqg4GL18 |
| Gyb6MUj5wyR4h5GkNZ9rUU5Ce5jbcunC2QUPUvXepump | CHILLDATE  | volatile   |         0.00 |         0.00 |     6 | 3gSqnvzNfQdSgWvzi7AX1nVhqEDJenxM9YNWxgPjr4Vz |
| 9wzzgMAv4X27SbHk3h7CmxyMXq5ZoUv6gjGc669Ypump | stgermain  | volatile   |         0.00 |         0.00 |     6 | CP7rs142xqGiNwd78dWxCvGGxfKUNpVairp6jxtypyt3 |
| Dkt6zeTA6pJBmPpS5TvcvChrjxpMfZdUtNEMBs5spump | ALPHA      | volatile   |         0.00 |         0.00 |     6 | A2BGbtm8yJ19JGB9FwLuDnQWJhM1Zuw86uUtvMagdrfw |
| 27VkFr6b6DHoR6hSYZjUDbwJsV6MPSFqPavXLg8nduHW | OSHO       | volatile   |         0.00 |         0.00 |     2 | 4RJ8LQhVjS2JL2iLgyjuyQ8CRc2Kkqdq6h43H38QVyQj |
| 9WnwzfYZbjfdJsm1s81Vn9rSV7THiKBNnhAyGBMCpump | CRYSTALS   | volatile   |         0.00 |         0.00 |     6 | 8KFq7cXzunNGaKmGAfZqLpVxjbyBe1UUPUZH5yEo14c5 |
| GjuSS9FHYKqFsYF3kiXCYu6teF7QUb1CqLt6aXGcpump | REMI       | volatile   |         0.00 |         0.00 |     6 | 6sqzDNY3E6v6abNbVAiACH2sGHaACwbbEuUKSShwKHq7 |
| 3r8igbjdAsWRyqo84FXBnpQFDEstTUu3GwkuUb8hpump | BREAD      | volatile   |         0.00 |         0.00 |  0.25 | AU6LZGa3UUCV6Jd5kBwV8dFnQ4jPnscpRTrTMdxbomKR |
| GbWDsxSYG36CfU5mmKSMpq1ANFuT97B9pW7pM2A8WEwV | CULT       | volatile   |         0.00 |         0.00 |     6 | CYaYTx1A8nFJJE8cFNWbDcbdQey11L8AEdru6v7MCR8F |
============================

// File: ./update-readme/src/main.rs
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::de::{self, Deserializer};
use serde::Deserialize;
use std::collections::{HashMap, HashSet};
use tokio::time::{sleep, Duration};

const CHEESE_MINT: &str = "A3hzGcTxZNSc7744CWB2LR5Tt9VTtEaQYpP6nwripump";

// -----------------------------------
// Part 1: Data Models
// -----------------------------------
#[derive(Debug, Deserialize)]
struct PaginatedPoolSearchResponse {
    data: Vec<MeteoraPool>,
    page: i32,
    total_count: i32,
}

#[derive(Debug, Deserialize)]
struct MeteoraPool {
    pool_address: String,
    pool_name: String,
    pool_token_mints: Vec<String>,
    pool_type: String,
    total_fee_pct: String,

    // For demonstration, we won't read these
    #[allow(dead_code)]
    unknown: bool,
    #[allow(dead_code)]
    permissioned: bool,

    #[serde(deserialize_with = "de_string_to_f64")]
    pool_tvl: f64,

    #[serde(alias = "trading_volume")]
    daily_volume: f64,

    // The amounts of each token in the pool, in `pool_token_mints` order
    #[serde(default)]
    pool_token_amounts: Vec<String>,
}

fn de_string_to_f64<'de, D>(deserializer: D) -> std::result::Result<f64, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    s.parse::<f64>().map_err(de::Error::custom)
}

/// Raydium mint query
#[derive(Debug, Deserialize)]
struct RaydiumMintIdsResponse {
    id: String,
    success: bool,
    data: Vec<Option<RaydiumMintItem>>,
}

#[derive(Debug, Deserialize)]
struct RaydiumMintItem {
    #[serde(default)]
    address: String,
    #[serde(default)]
    symbol: String,
}

/// Raydium cheese pools
#[derive(Debug, Deserialize)]
struct RaydiumMintPoolsResponse {
    id: String,
    success: bool,
    data: RaydiumMintPoolsData,
}

#[derive(Debug, Deserialize)]
struct RaydiumMintPoolsData {
    count: u64,
    data: Vec<RaydiumPoolDetailed>,
    #[allow(non_snake_case)]
    hasNextPage: bool,
}

#[derive(Debug, Deserialize)]
struct RaydiumPoolDetailed {
    #[serde(default)]
    r#type: String,
    #[serde(default)]
    programId: String,
    #[serde(default, alias = "id")]
    pool_id: String,

    mintA: RaydiumMintItem,
    mintB: RaydiumMintItem,

    #[serde(default)]
    price: f64,
    #[serde(default, alias = "mintAmountA")]
    mint_amount_a: f64,
    #[serde(default, alias = "mintAmountB")]
    mint_amount_b: f64,
    #[serde(default)]
    feeRate: f64,
    #[serde(default)]
    openTime: String,
    #[serde(default)]
    tvl: f64,

    #[serde(default)]
    day: RaydiumDayStats,
}

#[derive(Debug, Default, Deserialize)]
struct RaydiumDayStats {
    #[serde(default)]
    volume: f64,
}

/// Our final table row
#[derive(Debug)]
struct DisplayPool {
    source: String, // "Meteora" or "Raydium"
    other_mint: String,
    other_symbol: String,
    cheese_qty: String,
    other_qty: String,
    pool_type: String,
    liquidity_usd: String,
    volume_usd: String,
    fee: String,
    pool_address: String,
}

// Additional stats about Cheese
#[derive(Debug, Default)]
struct CheeseAggregates {
    // e.g. total USD liquidity across all pools
    total_liquidity_usd: f64,
    // total trades all-time, or daily trades, etc.
    // This is a placeholder example
    total_trades_all_time: u64,
    // total Cheese quantity (summed across all pools)
    total_cheese_qty: f64,
    // total daily volume across all Cheese pools
    total_volume_24h: f64,
}

// -----------------------------------
// Networking
// -----------------------------------
async fn fetch_meteora_cheese_pools(client: &Client) -> Result<Vec<MeteoraPool>> {
    let base_url = "https://amm-v2.meteora.ag";
    let search_url = format!("{}/pools/search", base_url);

    let mut all_pools = Vec::new();
    let mut page = 0;
    let size = 50;

    loop {
        println!("Requesting page {page} from {search_url}");
        let resp = client
            .get(&search_url)
            .query(&[
                ("page".to_string(), page.to_string()),
                ("size".to_string(), size.to_string()),
                ("include_token_mints".to_string(), CHEESE_MINT.to_string()),
            ])
            .send()
            .await?;

        if !resp.status().is_success() {
            return Err(anyhow!("Meteora request failed: {}", resp.status()));
        }

        let parsed: PaginatedPoolSearchResponse = resp.json().await?;
        println!(
            "Got {} pools on page {}, total_count={}",
            parsed.data.len(),
            parsed.page,
            parsed.total_count
        );

        all_pools.extend(parsed.data);

        let fetched_so_far = ((page + 1) * size) as i32;
        if fetched_so_far >= parsed.total_count {
            break;
        }
        page += 1;
    }

    println!(
        "\nFetched a total of {} Cheese pools from Meteora.\n",
        all_pools.len()
    );

    Ok(all_pools)
}

/// gather all unique mints
fn gather_all_mints(meteora: &[MeteoraPool]) -> HashSet<String> {
    let mut set = HashSet::new();
    set.insert(CHEESE_MINT.to_string());
    for pool in meteora {
        for m in &pool.pool_token_mints {
            set.insert(m.clone());
        }
    }
    set
}

async fn fetch_raydium_mint_ids(
    client: &Client,
    mints: &[String],
) -> Result<Vec<Option<RaydiumMintItem>>> {
    let joined = mints.join(",");
    let url = format!("https://api-v3.raydium.io/mint/ids?mints={}", joined);
    println!("Requesting minted data from Raydium for mints: {joined}");

    let resp = client.get(&url).send().await?;
    if !resp.status().is_success() {
        return Err(anyhow!(
            "Raydium /mint/ids request failed: {}",
            resp.status()
        ));
    }

    let parsed: RaydiumMintIdsResponse = resp.json().await?;
    if !parsed.success {
        return Err(anyhow!("Raydium /mint/ids returned success=false"));
    }

    println!(
        "Got {} minted items from Raydium (some may be None).",
        parsed.data.len()
    );
    Ok(parsed.data)
}

async fn fetch_raydium_cheese_pools(client: &Client) -> Result<Vec<RaydiumPoolDetailed>> {
    // fetch pools for cheese
    let url = format!(
        "https://api-v3.raydium.io/pools/info/mint?mint1={}&poolType=all&poolSortField=default&sortType=desc&pageSize=1000&page=1",
        CHEESE_MINT
    );
    println!("Requesting Raydium cheese pools from {url}");

    let resp = client.get(&url).send().await?;
    if !resp.status().is_success() {
        return Err(anyhow!(
            "Raydium cheese-pools request failed: {}",
            resp.status()
        ));
    }

    let parsed: RaydiumMintPoolsResponse = resp.json().await?;
    if !parsed.success {
        return Err(anyhow!("Raydium cheese-pools returned success=false"));
    }

    println!(
        "Raydium /pools/info/mint returned {} items\n",
        parsed.data.count
    );
    Ok(parsed.data.data)
}

// -----------------------------------
// Main
// -----------------------------------
#[tokio::main]
async fn main() -> Result<()> {
    let client = Client::new();

    // 1) fetch cheese pools from Meteora
    let meteora_pools = fetch_meteora_cheese_pools(&client).await?;

    // 2) gather mints from those pools
    let all_mints = gather_all_mints(&meteora_pools);
    let mut all_mints_vec: Vec<String> = all_mints.into_iter().collect();
    all_mints_vec.sort();

    // 3) fetch minted data for those from Raydium
    let minted_data = fetch_raydium_mint_ids(&client, &all_mints_vec).await?;
    let mut mint_to_symbol = HashMap::new();
    for maybe_item in &minted_data {
        if let Some(item) = maybe_item {
            if !item.address.is_empty() {
                mint_to_symbol.insert(item.address.clone(), item.symbol.clone());
            }
        }
    }

    // 4) convert meteora -> DisplayPool
    let mut cheese_aggs = CheeseAggregates::default();
    let mut final_pools = Vec::new();
    for pool in &meteora_pools {
        // figure out which side is Cheese, which is other
        let (cheese_ix, other_ix) = if pool.pool_token_mints.len() == 2 {
            if pool.pool_token_mints[0] == CHEESE_MINT {
                (0, 1)
            } else {
                (1, 0)
            }
        } else {
            (0, 0)
        };

        let cheese_amt_str = if pool.pool_token_amounts.len() > cheese_ix {
            pool.pool_token_amounts[cheese_ix].clone()
        } else {
            "".to_string()
        };
        // parse it as f64 for aggregates
        let cheese_amt_f64 = cheese_amt_str.parse::<f64>().unwrap_or(0.0);

        let other_mint = if pool.pool_token_mints.len() > other_ix {
            pool.pool_token_mints[other_ix].clone()
        } else {
            "".to_string()
        };
        let other_amt_str = if pool.pool_token_amounts.len() > other_ix {
            pool.pool_token_amounts[other_ix].clone()
        } else {
            "".to_string()
        };
        let other_amt_f64 = other_amt_str.parse::<f64>().unwrap_or(0.0);

        // fallback symbol
        let other_symbol = mint_to_symbol
            .get(&other_mint)
            .cloned()
            .unwrap_or_else(|| parse_other_token_name(&pool.pool_name));

        // aggregate
        cheese_aggs.total_liquidity_usd += pool.pool_tvl;
        cheese_aggs.total_volume_24h += pool.daily_volume;
        cheese_aggs.total_cheese_qty += cheese_amt_f64;
        // total_trades_all_time is arbitrary placeholder here
        cheese_aggs.total_trades_all_time += 1; // pretend each pool is "one trade"? replace as needed

        final_pools.push(DisplayPool {
            source: "Meteora".to_string(),
            other_mint: other_mint,
            other_symbol,
            cheese_qty: format!("{:.2}", cheese_amt_f64),
            other_qty: format!("{:.2}", other_amt_f64),
            pool_type: pool.pool_type.clone(),
            liquidity_usd: format!("{:.2}", pool.pool_tvl),
            volume_usd: format!("{:.2}", pool.daily_volume),
            fee: pool.total_fee_pct.clone(),
            pool_address: pool.pool_address.clone(),
        });
    }

    // 5) fetch Raydium cheese pools
    let raydium_cheese_pools = fetch_raydium_cheese_pools(&client).await?;
    for rp in &raydium_cheese_pools {
        let (cheese_side_amt, other_side_amt, other_mint_addr, other_symbol) =
            if rp.mintA.address == CHEESE_MINT {
                let oh_mint = rp.mintB.address.clone();
                let oh_sym = mint_to_symbol
                    .get(&oh_mint)
                    .cloned()
                    .unwrap_or_else(|| rp.mintB.symbol.clone());
                (rp.mint_amount_a, rp.mint_amount_b, oh_mint, oh_sym)
            } else {
                let oh_mint = rp.mintA.address.clone();
                let oh_sym = mint_to_symbol
                    .get(&oh_mint)
                    .cloned()
                    .unwrap_or_else(|| rp.mintA.symbol.clone());
                (rp.mint_amount_b, rp.mint_amount_a, oh_mint, oh_sym)
            };

        cheese_aggs.total_liquidity_usd += rp.tvl;
        cheese_aggs.total_volume_24h += rp.day.volume;
        cheese_aggs.total_cheese_qty += cheese_side_amt;
        cheese_aggs.total_trades_all_time += 2; // e.g. let's pretend each Raydium pool is "two trades"

        let fee_str = format!("{:.4}", rp.feeRate);
        final_pools.push(DisplayPool {
            source: "Raydium".to_string(),
            other_mint: other_mint_addr,
            other_symbol,
            cheese_qty: format!("{:.2}", cheese_side_amt),
            other_qty: format!("{:.2}", other_side_amt),
            pool_type: rp.r#type.clone(),
            liquidity_usd: format!("{:.2}", rp.tvl),
            volume_usd: format!("{:.2}", rp.day.volume),
            fee: fee_str,
            pool_address: rp.pool_id.clone(),
        });
    }

    // Print stats first
    println!("===== Cheese Aggregates =====");
    println!(
        "Total Liquidity (USD):   ${:.2}",
        cheese_aggs.total_liquidity_usd
    );
    println!(
        "Total 24H Volume (USD): ${:.2}",
        cheese_aggs.total_volume_24h
    );
    println!(
        "All-Time Trades:        {}",
        cheese_aggs.total_trades_all_time
    );
    println!(
        "Total Cheese qty:       {:.2}",
        cheese_aggs.total_cheese_qty
    );
    println!("=============================\n");

    // Then print table
    print_table(&final_pools);

    sleep(Duration::from_secs(2)).await;
    Ok(())
}

// -----------------------------------
// Helper Functions
// -----------------------------------
fn parse_other_token_name(pool_name: &str) -> String {
    let parts: Vec<&str> = pool_name.split('-').collect();
    if parts.len() == 2 {
        let left = parts[0].trim();
        let right = parts[1].trim();
        if left.contains("🧀") || left.to_lowercase().contains("cheese") {
            return right.to_string();
        }
        if right.contains("🧀") || right.to_lowercase().contains("cheese") {
            return left.to_string();
        }
        return right.to_string();
    }
    pool_name.to_string()
}

fn print_table(pools: &[DisplayPool]) {
    println!(
        "| {:<8} | {:<44} | {:<10} | {:>10} | {:>10} | {:<10} | {:>12} | {:>12} | {:>5} | {:<44} |",
        "Source",
        "Other Mint",
        "Symbol",
        "Cheese Qty",
        "Other Qty",
        "Pool Type",
        "Liquidity($)",
        "Volume($)",
        "Fee",
        "Pool Address",
    );

    println!(
        "|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|-{}-|",
        "-".repeat(8),
        "-".repeat(44),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(10),
        "-".repeat(12),
        "-".repeat(12),
        "-".repeat(5),
        "-".repeat(44),
    );

    for dp in pools {
        println!(
            "| {:<8} | {:<44} | {:<10} | {:>10} | {:>10} | {:<10} | {:>12} | {:>12} | {:>5} | {:<44} |",
            dp.source,
            truncate(&dp.other_mint, 44),
            truncate(&dp.other_symbol, 10),
            dp.cheese_qty,
            dp.other_qty,
            truncate(&dp.pool_type, 10),
            dp.liquidity_usd,
            dp.volume_usd,
            dp.fee,
            truncate(&dp.pool_address, 44),
        );
    }
}

fn truncate(input: &str, max_len: usize) -> String {
    if input.len() <= max_len {
        input.to_string()
    } else {
        format!("{}…", &input[..max_len.saturating_sub(1)])
    }
}

============================

// File: ./Readme.md
# Packages

## Update-Readme

This package is used to update the 🧀 repository's Markdown table of pools. 

It's really just practice code, you can get the data like:

```bash
curl https://amm-v2.meteora.ag/pools/'search?page=0&size=50&include_token_mints=A3hzGcTxZNSc7744CWB2LR5Tt9VTtEaQYpP6nwripump'
```
============================


Breakdown of file sizes by type:
=============================
